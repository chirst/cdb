// select generates a query plan for a selectStmt from an AST (Abstract Syntax
// Tree) generated by the parser. This plan is then fed to the vm (Virtual
// Machine) to be ran.
package main

// TODO
// This planner will eventually consist of smaller parts.
// 1. Something like a binder may be necessary which would validate the values
//    in the statement make sense given the current schema.
// 2. A logical query planner which would transform the ast into a relational
//    algebra like structure. This structure would allow for optimizations like
//    predicate push down.
// 3. Perhaps a physical planner which would maybe take into account statistics
//    and indexes.
// Somewhere in these structures would be the ability to print a query plan that
// is higher level than the bytecode operations. A typical explain tree.

import "github.com/chirst/cdb/compiler"

// selectCatalog defines the catalog methods needed by the select planner
type selectCatalog interface {
	getColumns(tableOrIndexName string) ([]string, error)
	getRootPageNumber(tableOrIndexName string) (int, error)
}

type selectPlanner struct {
	catalog selectCatalog
}

func newSelectPlanner(catalog selectCatalog) *selectPlanner {
	return &selectPlanner{
		catalog: catalog,
	}
}

func (p *selectPlanner) getPlan(s *compiler.SelectStmt) (*executionPlan, error) {
	resultHeader := []*string{}
	cols, err := p.catalog.getColumns(s.From.TableName)
	if err != nil {
		return nil, err
	}
	for _, c := range cols {
		if s.ResultColumn.All {
			resultHeader = append(resultHeader, &c)
		}
	}
	rootPage, err := p.catalog.getRootPageNumber(s.From.TableName)
	if err != nil {
		return nil, err
	}
	cursorId := 1
	commands := []command{}
	commands = append(commands, &initCmd{p2: 1})
	commands = append(commands, &transactionCmd{p2: 0})
	commands = append(commands, &openReadCmd{p1: cursorId, p2: rootPage})
	rwc := &rewindCmd{p1: cursorId}
	commands = append(commands, rwc)
	commands = append(commands, &rowIdCmd{p1: cursorId, p2: 1})
	colIdx := 0
	registerIdx := 2
	gap := 0
	for _, c := range cols {
		if c == "id" {
			continue
		}
		commands = append(commands, &columnCmd{p1: cursorId, p2: colIdx, p3: registerIdx})
		colIdx += 1
		registerIdx += 1
		gap += 1
	}
	commands = append(commands, &resultRowCmd{p1: 1, p2: gap + 1})
	commands = append(commands, &nextCmd{p1: cursorId, p2: 4})
	commands = append(commands, &haltCmd{p2: 0})
	rwc.p2 = len(commands) - 1
	return &executionPlan{
		explain:      s.Explain,
		commands:     commands,
		resultHeader: resultHeader,
	}, nil
}
