// select generates a query plan for a selectStmt from an AST (Abstract Syntax
// Tree) generated by the parser. This plan is then fed to the vm (Virtual
// Machine) to be ran.
package main

import "github.com/chirst/cdb/compiler"

type selectPlanner struct {
	catalog *catalog
}

func newSelectPlanner(catalog *catalog) *selectPlanner {
	return &selectPlanner{
		catalog: catalog,
	}
}

// func (p *selectPlanner) getPlan(s *compiler.SelectStmt) (*executionPlan, error) {
// 	lp, err := p.getLogicalPlan(s)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return p.getPhysicalPlan(lp, s.Explain)
// }

// func (l *selectPlanner) getLogicalPlan(s *compiler.SelectStmt) (*projection, error) {
// 	p := &projection{}
// 	tablePageNumber := 0
// 	var tableColumns []string
// 	if s.From != nil && s.From.TableName != "" {
// 		tpn, err := l.catalog.getPageNumber(s.From.TableName)
// 		if err != nil {
// 			return nil, err
// 		}
// 		tcs, err := l.catalog.getColumns(s.From.TableName)
// 		if err != nil {
// 			return nil, err
// 		}
// 		tablePageNumber = tpn
// 		tableColumns = tcs
// 	}
// 	if s.ResultColumn.All {
// 		p.fields = tableColumns
// 	}
// 	p.childSet = set{
// 		rootPage: tablePageNumber,
// 	}
// 	return p, nil
// }

// // Projection is the root of a logical query plan.
// type projection struct {
// 	// Fields to project from the set.
// 	fields []string
// 	// Set that is being projected.
// 	childSet set
// }

// type set struct {
// 	// Page number of corresponding index or table.
// 	rootPage int
// }

func (p *selectPlanner) getPlan(s *compiler.SelectStmt) (*executionPlan, error) {
	resultHeader := []*string{}
	cols, err := p.catalog.getColumns(s.From.TableName)
	if err != nil {
		return nil, err
	}
	for _, c := range cols {
		if s.ResultColumn.All {
			resultHeader = append(resultHeader, &c)
		}
	}
	rootPage, err := p.catalog.getRootPageNumber(s.From.TableName)
	if err != nil {
		return nil, err
	}
	cursorId := 1
	commands := []command{}
	commands = append(commands, &initCmd{p2: 1})
	commands = append(commands, &transactionCmd{p2: 0})
	commands = append(commands, &openReadCmd{p1: cursorId, p2: rootPage})
	rwc := &rewindCmd{p1: cursorId}
	commands = append(commands, rwc)
	commands = append(commands, &rowIdCmd{p1: cursorId, p2: 1})
	colIdx := 0
	registerIdx := 2
	gap := 0
	for _, c := range cols {
		if c == "id" {
			continue
		}
		commands = append(commands, &columnCmd{p1: cursorId, p2: colIdx, p3: registerIdx})
		colIdx += 1
		registerIdx += 1
		gap += 1
	}
	commands = append(commands, &resultRowCmd{p1: 1, p2: gap + 1})
	commands = append(commands, &nextCmd{p1: cursorId, p2: 4})
	commands = append(commands, &haltCmd{p2: 0})
	rwc.p2 = len(commands) - 1
	return &executionPlan{
		explain:      s.Explain,
		commands:     commands,
		resultHeader: resultHeader,
	}, nil
}
