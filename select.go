// select generates a query plan for a selectStmt from an AST (Abstract Syntax
// Tree) generated by the parser. This plan is then fed to the vm (Virtual
// Machine) to be ran.
package main

import "github.com/chirst/cdb/compiler"

func newLogicalPlanner() *logicalPlanner {
	return &logicalPlanner{
		catalog: newCatalog(),
	}
}

func (l *logicalPlanner) forSelect(s *compiler.SelectStmt) *projection {
	p := &projection{}
	tablePageNumber := 0
	var tableColumns []string
	if s.From != nil && s.From.TableName != "" {
		tpn, err := l.catalog.getPageNumber(s.From.TableName)
		if err != nil {
			// handle
		}
		tcs, err := l.catalog.getColumns(s.From.TableName)
		if err != nil {
			// handle
		}
		tablePageNumber = tpn
		tableColumns = tcs
	}
	if s.ResultColumn.All {
		p.fields = tableColumns
	}
	p.childSet = set{
		rootPage: tablePageNumber,
	}
	return p
}

type logicalPlanner struct {
	catalog *catalog
}

// Projection is the root of a logical query plan.
type projection struct {
	// Fields to project from the set.
	fields []string
	// Set that is being projected.
	childSet set
}

type set struct {
	// Page number of corresponding index or table.
	rootPage int
}

type physicalPlanner struct{}

func newPhysicalPlanner() *physicalPlanner {
	return &physicalPlanner{}
}

func (*physicalPlanner) forSelect(projection *projection, explain bool) *executionPlan {
	commands := map[int]command{}
	commands[1] = &initCmd{p2: 2}
	commands[2] = &transactionCmd{}
	commands[3] = &openReadCmd{p2: 2}
	commands[4] = &rewindCmd{p2: 9}
	commands[5] = &rowIdCmd{p2: 1}
	commands[6] = &columnCmd{p2: 1, p3: 2}
	commands[7] = &resultRowCmd{p1: 1, p2: 2}
	commands[8] = &nextCmd{p2: 5}
	commands[9] = &haltCmd{}
	return &executionPlan{
		explain:  explain,
		commands: commands,
	}
}
