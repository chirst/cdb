package planner

import (
	"fmt"
	"slices"

	"github.com/chirst/cdb/compiler"
	"github.com/chirst/cdb/vm"
)

// pkConstraint is the error message displayed when a primary key constraint is
// violated.
const pkConstraint = "pk unique constraint violated"

// insertCatalog defines the catalog methods needed by the insert planner
type insertCatalog interface {
	GetColumns(tableOrIndexName string) ([]string, error)
	GetRootPageNumber(tableOrIndexName string) (int, error)
	GetVersion() string
	GetPrimaryKeyColumn(tableName string) (string, error)
}

// insertPlanner consists of planners capable of generating a logical query plan
// tree and bytecode execution plan for a insert statement.
type insertPlanner struct {
	// catalog contains the schema.
	catalog insertCatalog
	// stmt contains the AST.
	stmt *compiler.InsertStmt
	// queryPlan contains the query plan being constructed. For an insert, the
	// root node must be an insertNode.
	queryPlan *insertNode
	// executionPlan contains the execution plan generated by calling
	// ExecutionPlan.
	executionPlan *vm.ExecutionPlan
}

// NewInsert returns an instance of an insert planner for the given AST.
func NewInsert(catalog insertCatalog, stmt *compiler.InsertStmt) *insertPlanner {
	return &insertPlanner{
		catalog: catalog,
		stmt:    stmt,
		executionPlan: vm.NewExecutionPlan(
			catalog.GetVersion(),
			stmt.Explain,
		),
	}
}

// QueryPlan generates the query plan tree for the planner.
func (p *insertPlanner) QueryPlan() (*QueryPlan, error) {
	rootPage, err := p.catalog.GetRootPageNumber(p.stmt.TableName)
	if err != nil {
		return nil, errTableNotExist
	}
	if err := p.checkValuesMatchColumns(p.stmt); err != nil {
		return nil, err
	}
	colValues, err := p.getNonPkValues()
	if err != nil {
		return nil, err
	}
	insertNode := &insertNode{
		colValues: colValues,
	}
	if err := p.setPkValues(insertNode); err != nil {
		return nil, err
	}
	p.queryPlan = insertNode
	qp := newQueryPlan(
		insertNode,
		p.stmt.ExplainQueryPlan,
		transactionTypeWrite,
		rootPage,
	)
	insertNode.plan = qp
	return qp, nil
}

func (p *insertPlanner) setPkValues(n *insertNode) error {
	pkColumnName, err := p.catalog.GetPrimaryKeyColumn(p.stmt.TableName)
	if err != nil {
		return err
	}
	statementPkIdx := -1
	if pkColumnName != "" {
		statementPkIdx = slices.IndexFunc(p.stmt.ColNames, func(s string) bool {
			return s == pkColumnName
		})
	}
	if statementPkIdx == -1 {
		n.autoPk = true
	} else {
		n.autoPk = false
		n.pkValues = []compiler.Expr{}
		for _, v := range p.stmt.ColValues {
			n.pkValues = append(n.pkValues, v[statementPkIdx])
		}
	}
	return nil
}

func (p *insertPlanner) getNonPkValues() ([][]compiler.Expr, error) {
	pkColumnName, err := p.catalog.GetPrimaryKeyColumn(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	catalogColumnNames, err := p.catalog.GetColumns(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	resultValues := [][]compiler.Expr{}
	for _, colValue := range p.stmt.ColValues {
		resultValue := []compiler.Expr{}
		for _, cn := range catalogColumnNames {
			if cn == pkColumnName {
				continue
			}
			stmtColIdx := slices.IndexFunc(p.stmt.ColNames, func(stmtColName string) bool {
				return stmtColName == cn
			})
			if stmtColIdx == -1 {
				return nil, fmt.Errorf("%w %s", errMissingColumnName, cn)
			}
			resultValue = append(resultValue, colValue[stmtColIdx])
		}
		resultValues = append(resultValues, resultValue)
	}
	return resultValues, nil
}

// ExecutionPlan returns the bytecode routine for the planner. Calling QueryPlan
// is not prerequisite to calling ExecutionPlan as ExecutionPlan will be called
// as needed.
func (p *insertPlanner) ExecutionPlan() (*vm.ExecutionPlan, error) {
	if p.queryPlan == nil {
		_, err := p.QueryPlan()
		if err != nil {
			return nil, err
		}
	}
	p.queryPlan.plan.compile()
	p.executionPlan.Commands = p.queryPlan.plan.commands
	return p.executionPlan, nil
}

func (p *insertPlanner) checkValuesMatchColumns(s *compiler.InsertStmt) error {
	cl := len(s.ColNames)
	for _, cv := range s.ColValues {
		if cl != len(cv) {
			return errValuesNotMatch
		}
	}
	return nil
}
