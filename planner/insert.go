package planner

import (
	"github.com/chirst/cdb/compiler"
	"github.com/chirst/cdb/vm"
)

// pkConstraint is the error message displayed when a primary key constraint is
// violated.
const pkConstraint = "pk unique constraint violated"

// insertCatalog defines the catalog methods needed by the insert planner
type insertCatalog interface {
	GetColumns(tableOrIndexName string) ([]string, error)
	GetRootPageNumber(tableOrIndexName string) (int, error)
	GetVersion() string
	GetPrimaryKeyColumn(tableName string) (string, error)
}

// insertPlanner consists of planners capable of generating a logical query plan
// tree and bytecode execution plan for a insert statement.
type insertPlanner struct {
	// catalog contains the schema.
	catalog insertCatalog
	// stmt contains the AST.
	stmt *compiler.InsertStmt
	// queryPlan contains the query plan being constructed. For an insert, the
	// root node must be an insertNode.
	queryPlan *insertNode
	// executionPlan contains the execution plan generated by calling
	// ExecutionPlan.
	executionPlan *vm.ExecutionPlan
}

// NewInsert returns an instance of an insert planner for the given AST.
func NewInsert(catalog insertCatalog, stmt *compiler.InsertStmt) *insertPlanner {
	return &insertPlanner{
		catalog: catalog,
		stmt:    stmt,
		executionPlan: vm.NewExecutionPlan(
			catalog.GetVersion(),
			stmt.Explain,
		),
	}
}

// QueryPlan generates the query plan tree for the planner.
func (p *insertPlanner) QueryPlan() (*QueryPlan, error) {
	rootPage, err := p.catalog.GetRootPageNumber(p.stmt.TableName)
	if err != nil {
		return nil, errTableNotExist
	}
	catalogColumnNames, err := p.catalog.GetColumns(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	if err := p.checkValuesMatchColumns(p.stmt); err != nil {
		return nil, err
	}
	pkColumn, err := p.catalog.GetPrimaryKeyColumn(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	insertNode := &insertNode{
		rootPage:           rootPage,
		catalogColumnNames: catalogColumnNames,
		pkColumn:           pkColumn,
		colNames:           p.stmt.ColNames,
		colValues:          p.stmt.ColValues,
	}
	p.queryPlan = insertNode
	qp := newQueryPlan(
		insertNode,
		p.stmt.ExplainQueryPlan,
		transactionTypeWrite,
		rootPage,
	)
	insertNode.plan = qp
	return qp, nil
}

// ExecutionPlan returns the bytecode routine for the planner. Calling QueryPlan
// is not prerequisite to calling ExecutionPlan as ExecutionPlan will be called
// as needed.
func (p *insertPlanner) ExecutionPlan() (*vm.ExecutionPlan, error) {
	if p.queryPlan == nil {
		_, err := p.QueryPlan()
		if err != nil {
			return nil, err
		}
	}
	p.queryPlan.plan.compile()
	p.executionPlan.Commands = p.queryPlan.plan.commands
	return p.executionPlan, nil
}

func (p *insertPlanner) checkValuesMatchColumns(s *compiler.InsertStmt) error {
	cl := len(s.ColNames)
	for _, cv := range s.ColValues {
		if cl != len(cv) {
			return errValuesNotMatch
		}
	}
	return nil
}
