package planner

import (
	"errors"
	"fmt"
	"slices"
	"strconv"

	"github.com/chirst/cdb/compiler"
	"github.com/chirst/cdb/vm"
)

var (
	errTableNotExist     = errors.New("table does not exist")
	errValuesNotMatch    = errors.New("values list did not match columns list")
	errMissingColumnName = errors.New("missing column")
)

// insertCatalog defines the catalog methods needed by the insert planner
type insertCatalog interface {
	GetColumns(tableOrIndexName string) ([]string, error)
	GetRootPageNumber(tableOrIndexName string) (int, error)
	GetVersion() string
	GetPrimaryKeyColumn(tableName string) (string, error)
}

// insertPlanner consists of planners capable of generating a logical query plan
// tree and bytecode execution plan for a insert statement.
type insertPlanner struct {
	// The query planner generates a logical query plan tree made up of nodes
	// similar to relational algebra operators. The query planner performs
	// validation while building the tree. Otherwise known as binding.
	queryPlanner *insertQueryPlanner
	// The executionPlanner transforms the logical query plan tree to a bytecode
	// execution plan that can be ran by the virtual machine.
	executionPlanner *insertExecutionPlanner
}

// insertQueryPlanner converts the AST generated by the compiler to a logical
// query plan tree. It is also responsible for validating the AST against the
// system catalog.
type insertQueryPlanner struct {
	// catalog contains the schema.
	catalog insertCatalog
	// stmt contains the AST.
	stmt *compiler.InsertStmt
	// queryPlan contains the query plan being constructed. For an insert, the
	// root node must be an insertNode.
	queryPlan *insertNode
}

// insertExecutionPlanner converts the logical query plan to a bytecode routine
// to be ran by the vm.
type insertExecutionPlanner struct {
	// queryPlan contains the query plan generated by the query planner's
	// QueryPlan method.
	queryPlan *insertNode
	// executionPlan contains the execution plan generated by calling
	// ExecutionPlan.
	executionPlan *vm.ExecutionPlan
}

// NewInsert returns an instance of an insert planner for the given AST.
func NewInsert(catalog insertCatalog, stmt *compiler.InsertStmt) *insertPlanner {
	return &insertPlanner{
		queryPlanner: &insertQueryPlanner{
			catalog: catalog,
			stmt:    stmt,
		},
		executionPlanner: &insertExecutionPlanner{
			executionPlan: vm.NewExecutionPlan(
				catalog.GetVersion(),
				stmt.Explain,
			),
		},
	}
}

// QueryPlan generates the query plan tree for the planner.
func (p *insertPlanner) QueryPlan() (*QueryPlan, error) {
	qp, err := p.queryPlanner.getQueryPlan()
	if err != nil {
		return nil, err
	}
	p.executionPlanner.queryPlan = p.queryPlanner.queryPlan
	return qp, err
}

func (p *insertQueryPlanner) getQueryPlan() (*QueryPlan, error) {
	rootPage, err := p.catalog.GetRootPageNumber(p.stmt.TableName)
	if err != nil {
		return nil, errTableNotExist
	}
	catalogColumnNames, err := p.catalog.GetColumns(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	if err := checkValuesMatchColumns(p.stmt); err != nil {
		return nil, err
	}
	pkColumn, err := p.catalog.GetPrimaryKeyColumn(p.stmt.TableName)
	if err != nil {
		return nil, err
	}
	insertNode := &insertNode{
		rootPage:           rootPage,
		catalogColumnNames: catalogColumnNames,
		pkColumn:           pkColumn,
		colNames:           p.stmt.ColNames,
		colValues:          p.stmt.ColValues,
	}
	p.queryPlan = insertNode
	return newQueryPlan(insertNode, p.stmt.ExplainQueryPlan), nil
}

// ExecutionPlan returns the bytecode routine for the planner. Calling QueryPlan
// is not prerequisite to calling ExecutionPlan as ExecutionPlan will be called
// as needed.
func (p *insertPlanner) ExecutionPlan() (*vm.ExecutionPlan, error) {
	if p.queryPlanner.queryPlan == nil {
		_, err := p.QueryPlan()
		if err != nil {
			return nil, err
		}
	}
	return p.executionPlanner.getExecutionPlan()
}

func (p *insertExecutionPlanner) getExecutionPlan() (*vm.ExecutionPlan, error) {
	p.buildInit()
	cursorId := 1
	p.executionPlan.Append(&vm.OpenWriteCmd{P1: cursorId, P2: p.queryPlan.rootPage})
	for valueIdx := range len(p.queryPlan.colValues) / len(p.queryPlan.colNames) {
		keyRegister := 1
		statementIDIdx := -1
		if p.queryPlan.pkColumn != "" {
			statementIDIdx = slices.IndexFunc(p.queryPlan.colNames, func(s string) bool {
				return s == p.queryPlan.pkColumn
			})
		}
		if statementIDIdx == -1 {
			p.executionPlan.Append(&vm.NewRowIdCmd{P1: p.queryPlan.rootPage, P2: keyRegister})
		} else {
			rowId, err := strconv.Atoi(p.queryPlan.colValues[statementIDIdx+valueIdx*len(p.queryPlan.colNames)])
			if err != nil {
				return nil, err
			}
			integerCmdIdx := len(p.executionPlan.Commands) + 2
			p.executionPlan.Append(&vm.NotExistsCmd{P1: p.queryPlan.rootPage, P2: integerCmdIdx, P3: rowId})
			p.executionPlan.Append(&vm.HaltCmd{P1: 1, P4: "pk unique constraint violated"})
			p.executionPlan.Append(&vm.IntegerCmd{P1: rowId, P2: keyRegister})
		}
		registerIdx := keyRegister
		for _, catalogColumnName := range p.queryPlan.catalogColumnNames {
			if catalogColumnName != "" && catalogColumnName == p.queryPlan.pkColumn {
				continue
			}
			registerIdx += 1
			vIdx := -1
			for i, statementColumnName := range p.queryPlan.colNames {
				if statementColumnName == catalogColumnName {
					vIdx = i + (valueIdx * len(p.queryPlan.colNames))
				}
			}
			if vIdx == -1 {
				return nil, fmt.Errorf("%w %s", errMissingColumnName, catalogColumnName)
			}
			p.executionPlan.Append(&vm.StringCmd{P1: registerIdx, P4: p.queryPlan.colValues[vIdx]})
		}
		p.executionPlan.Append(&vm.MakeRecordCmd{P1: 2, P2: registerIdx - 1, P3: registerIdx + 1})
		p.executionPlan.Append(&vm.InsertCmd{P1: p.queryPlan.rootPage, P2: registerIdx + 1, P3: keyRegister})
	}
	p.executionPlan.Append(&vm.HaltCmd{})
	return p.executionPlan, nil
}

func (p *insertExecutionPlanner) buildInit() {
	p.executionPlan.Append(&vm.InitCmd{P2: 1})
	p.executionPlan.Append(&vm.TransactionCmd{P2: 1})
}

func checkValuesMatchColumns(s *compiler.InsertStmt) error {
	// TODO need to enhance for INSERT INTO foo (name) VALUES ('n1', 'n2')
	vl := len(s.ColValues)
	cl := len(s.ColNames)
	if vl%cl != 0 {
		return errValuesNotMatch
	}
	return nil
}
