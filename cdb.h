/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package command-line-arguments */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */




/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


// cdb_new_db opens a database with the given filename. A filename of ":memory:"
// will open a database that does not persist data after it is closed. A non
// zero int is returned in case an error occurs. The database can be closed with
// cdb_close_db.
//
extern int cdb_new_db(char* filename);

// cdb_close_db closes the database with the given filename.
//
extern void cdb_close_db(char* filename);

// cdb_prepare prepares a statement that can be bound and executed for the given
// filename and sql. The prepareId is a handle used for further operations on
// the prepared statement. Note the prepared statement must be cleaned up with
// cdb_close_statement.
//
// If an error is encountered during prepare err code 2 is returned and the
// error message is written to prepareErr.
//
extern int cdb_prepare(int* prepareId, char* filename, char* sql, char** prepareErr);

// cdb_close_statement cleans up a prepared statement.
//
extern void cdb_close_statement(int prepareId);

// cdb_bind_int binds an int as the next available argument for the given
// prepared statement.
//
extern int cdb_bind_int(int prepareId, int bound);

// cdb_bind_string binds a string as the next available argument for the given
// prepared statement.
//
extern int cdb_bind_string(int prepareId, char* bound);

// cdb_execute evaluates the given prepared statement.
//
extern int cdb_execute(int prepareId);

// cdb_result_err puts 1 in hasError when the statement has an error. The error
// message is put in errMessage.
//
extern int cdb_result_err(int prepareId, int* hasError, char** errMessage);

// cdb_result_row moves a cursor to the next row. If there is no row
// cdb_result_row will put 1 into hasRow otherwise 0.
//
extern int cdb_result_row(int prepareId, int* hasRow);

// cdb_result_col_int puts the int for the current row at the 0 based column
// index for the result param.
//
extern int cdb_result_col_int(int prepareId, int colIdx, int* result);

// cdb_result_col_string puts the string for the current row at the 0 based
// column index into the result param.
//
extern int cdb_result_col_string(int prepareId, int colIdx, char** result);

// cdb_result_col_count puts the count of result columns in result for the given
// prepareId.
//
extern int cdb_result_col_count(int prepareId, int* result);

// cdb_result_col_name puts the result column name in the result for the given
// colIdx and the the given prepareId.
//
extern int cdb_result_col_name(int prepareId, int colIdx, char** result);

// cdb_result_col_type puts the type of the result column in result for the
// given prepareId and colIdx. This function will tell what kind of cdb_result_*
// function is able to extract the underlying value in the column.
//
// The types of result can be:
// 0 - UNKNOWN
// 1 - VARIABLE
// 2 - INTEGER
// 3 - TEXT
//
extern int cdb_result_col_type(int prepareId, int colIdx, int* result);

#ifdef __cplusplus
}
#endif
